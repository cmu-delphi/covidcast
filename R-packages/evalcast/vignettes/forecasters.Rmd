---
title: "Introduction to Compatible Forecasters"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to evalcast}
  %\VignetteEngine{knitr::knitr}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE, message = FALSE, warning = FALSE,
  collapse = TRUE,
  comment = "#>"
)
```


The `evalcast` package provides the infrastructure for developing and evaluating probabilistic forecasters that are based on data obtained with the [covidcast](https://cmu-delphi.github.io/covidcast/covidcastR/) R package.  In the [intro vignette](https://cmu-delphi.github.io/covidcast/evalcastR/articles/intro-evalcast.html) we cover using the included `baseline_forecaster` to show the process of backtesting and comparing forecasters.  Evalcast is not limited to this forecaster; is to be able to evaluate a wide range of forecasters, including those that do not use `covidcast` data.  We will demonstrate what is needed to make a forecaster and cover how to implement certain use cases.


### Structure of a Forecaster

A forecaster needs to output a tibble with columns `ahead`, `geo_value`, `quantile` and `value`.  `quantile` can be set to `NA` for point forecasters.  A forecaster is designed to be used with the `get_predictions` function, but forecasters can be created manually and passed to `evaluate_predictions`.  We are going to cover how to use a forecaster with `get_predictions`. 

In order to use `evaluate_predictions`, the predictions ahead, geo_value, quantile, value, forecaster, forecast_date, data_source, signal, target_end_date, and incidence_period.  Forecasters using `get_predictions` are passed to `get_predictions_single_date` for a specific date, and then this line of code is executed:

```
out <- forecaster(df,
                  forecast_date,
                  signals,
                  incidence_period,
                  ahead,
                  geo_type,
                  ...)
```

A forecaster must have the inputs `df` (which is generated by `download_signals` to get covidcast signals), `signals` (from covidcast), `incidence_period`, `ahead`, and `geo_type`.  However, it doesn't have to use the covidcast data, just take it as inputs!  We can use other inputs; the `...` handles those.  We cover that case in the **Using other data** section.  

Another note is that a forecaster is passed as function to `get_predictions`.  The inputs for the forecaster are also passed to `get_predictions`.  

In summary, to use your own forecaster you need to:

1. Define your forecaster as a function or construct another function that returns your forecaster function

2. Pass your forecaster, the required inputs and your forecasters inputs to `get_predictions` to get a dataframe of predictions!

## Example using data from covidcast

Let's build a simple point forecaster where the forecasted number of cases is multiplied by some factor (ex. doubled) in a week. We are going to do this in two ways: first by passing the doubling growth factor in as an input from `get_predictions`.

First, we implement this forecaster as below with the growth factor as a parameter that is passed in to the forecaster.

```{r, include = TRUE}

growth_factor_forecaster <- function(df,
                                     forecast_date,
                                     signals,
                                     incidence_period = "epiweek",
                                     ahead,
                                     geo_type,
                                     growth_factor) {
  dat <- list()
  for (a in seq_along(ahead)) {
    # recall the first row of signals is the response
    dat[[a]] <- df %>%
      dplyr::filter(.data$data_source == signals$data_source[1],
                    .data$signal == signals$signal[1])  %>%
      dplyr::group_by(.data$geo_value) %>%
      dplyr::arrange(.data$time_value) %>%
      dplyr::slice_tail(n = 1) %>%
      dplyr::mutate(value = .data$value * growth_factor ** a,
                    quantile = NA) %>%
      dplyr::select(.data$geo_value, .data$value, .data$quantile) %>%
      dplyr::ungroup() 
  }
  names(dat) <- as.character(ahead)
  dplyr::bind_rows(dat, .id = "ahead") %>%
    dplyr::mutate(ahead = as.integer(ahead))
}

```
 
Then we can call `get_predictions` using this forecaster as such!  Remember to past in custom inputs to `get_predictions`.


```{r, include = TRUE}
library(tibble)
library(dplyr)
library(covidcast)
library(evalcast)
library(lubridate)
library(ggplot2)

signals <- tibble(data_source = "jhu-csse", 
                  signal = c("confirmed_incidence_num"), 
                  start_day = "2020-06-15")

# Get first half of July dates to perform forecasts on
forecast_dates <- get_covidhub_forecast_dates("CMU-TimeSeries")
forecast_dates <- forecast_dates[forecast_dates >= "2020-10-01" & 
                                   forecast_dates <= "2020-10-31"]

predictions_cards <- get_predictions(forecaster = growth_factor_forecaster,
                                     name_of_forecaster = 'Doubling',
                                     signals = signals,
                                     forecast_dates = forecast_dates,
                                     incidence_period = 'epiweek',
                                     ahead = c(1,2,3),
                                     geo_type = 'state',
                                     signal_aggregation = "long",
                                     growth_factor = 2)

predictions_cards %>% dplyr::filter(.$geo_value == 'pa')
```
 
Now we are going to use the same forecaster but implemented in a different way.  Essentially, implement the forecaster with the required inputs from evalcast inside a function where you have the custom inputs, then return the inner forecaster function.

```{r, include = TRUE}

get_growth_factor_forecaster <- function(growth_factor){
  
  growth_factor_forecaster <- function(df,
                                       forecast_date,
                                       signals,
                                       incidence_period = "epiweek",
                                       ahead,
                                       geo_type) {
    dat <- list()
    for (a in seq_along(ahead)) {
      # recall the first row of signals is the response
      dat[[a]] <- df %>%
        dplyr::filter(.data$data_source == signals$data_source[1],
                      .data$signal == signals$signal[1])  %>%
        dplyr::group_by(.data$geo_value) %>%
        dplyr::arrange(.data$time_value) %>%
        dplyr::slice_tail(n = 1) %>%
        dplyr::mutate(value = .data$value * growth_factor ** a,
                      quantile = NA) %>%
        dplyr::select(.data$geo_value, .data$value, .data$quantile) %>%
        dplyr::ungroup() 
    }
    names(dat) <- as.character(ahead)
    dplyr::bind_rows(dat, .id = "ahead") %>%
      dplyr::mutate(ahead = as.integer(ahead))
  }
  
  return(growth_factor_forecaster)
}

doubling_forecaster = get_growth_factor_forecaster(2)

predictions_cards <- get_predictions(forecaster = doubling_forecaster,
                                     name_of_forecaster = 'Doubling',
                                     signals = signals,
                                     forecast_dates = forecast_dates,
                                     incidence_period = 'epiweek',
                                     ahead = c(1,2,3),
                                     geo_type = 'state',
                                     signal_aggregation = 'long')

predictions_cards %>% dplyr::filter(.$geo_value == 'pa')

```

We get the same results!  Same forecaster, two different ways to pass it to `get_predictions`. 

### Covidcast forecaster inputs

When building a forecaster using covidcast signals, you must select what format the signal data will be given to your forecaster and pass that format type as an input to `get_predictions`.  The three options are `list`, `long`, and `wide`.  `get_predictions` calls 'download_signals', a wrapper around `covidcast::covidcast_signals()`[https://cmu-delphi.github.io/covidcast/covidcastR/reference/covidcast_signals.html] and `covidcast::aggregate_signals()`[https://cmu-delphi.github.io/covidcast/covidcastR/reference/aggregate_signals.html].  

For the signal

```
signals <- tibble(data_source = "jhu-csse", 
                  signal = c("confirmed_incidence_num"), 
                  start_day = "2020-06-15")
```

we will go through the various forecaster input options.

The `list` option will return a list of dataframes from `covidcast::covidcast_signals()`.  The list format gives list of `covidcast_signal` dataframes for each signal.  For the signals

```
signals  <- tibble(data_source = c("usa-facts", "jhu-csse"), 
                  signal = c("confirmed_incidence_num"), 
                  start_day = "2020-10-01")
```

the outputs will be a list of two dataframes, as shown below.  The `covidcast` documentation for [`covidcast_signals`](https://cmu-delphi.github.io/covidcast/covidcastR/reference/covidcast_signals.html) provides further details for the output of the `list` option.

```{r, include = TRUE}

signals <- tibble(data_source = c("usa-facts", "jhu-csse"), 
                  signal = c("confirmed_incidence_num"), 
                  start_day = "2020-10-01")

forecast_date <- "2020-10-10"


df <- download_signals(data_source=signals$data_source,
                       signal = signals$signal,
                       start_day = signals$start_day,
                       end_day = forecast_date,
                       as_of = forecast_date,
                       geo_type = "state",
                       geo_values = "*",
                       signal_aggregation = "list",
                       signal_aggregation_dt = NULL)

head(df[[1]])

head(df[[2]])

```


The `long` format will aggregate these seperate dataframes into one dataframe.  As you can see, both the `jhu-case` and `usa-facts` signals are in the same dataframe.  

```{r, include = TRUE}

df <- download_signals(data_source=signals$data_source,
                       signal = signals$signal,
                       start_day = signals$start_day,
                       end_day = forecast_date,
                       as_of = forecast_date,
                       geo_type = "state",
                       geo_values = "*",
                       signal_aggregation = "long",
                       signal_aggregation_dt = NULL)

head(df %>% dplyr::arrange(geo_value, time_value))

```

The `wide` 

```{r, include = TRUE}

df <- download_signals(data_source=signals$data_source,
                       signal = signals$signal,
                       start_day = signals$start_day,
                       end_day = forecast_date,
                       as_of = forecast_date,
                       geo_type = "state",
                       geo_values = "*",
                       signal_aggregation = "wide",
                       signal_aggregation_dt = NULL)

head(df)

```

### Making Corrections

To make corrections on the covidcast data, pass a corrections function to `get_predictions` by the `apply_corrections` input. Your `apply_corrections` function will correct the data returned by `download_signals` for each `as_of` date from `covidcast`, not the forecasts.  Additionally, `apply_corrections` passed in for `get_predictions` only corrects covidcast data, not other data.  To correct other data, that would need to be contained within the forecaster.

The `apply_corrections` function will take the output of `download_signals` as input; so it will need to expect the same input format as the forecaster.  See the previous section for more details on input formats.

### Using other data 

If you want to use non-covidcast data for your forecaster, there are a couple different ways that can be done.  No matter which way you select, there are some things to note:

  1.`use_covidcast` must be set to FALSE an as input to `get_predictions` (it is set to TRUE by default).  This prevents any downloading being done by the API.
  
  2. You need to define a `signal` input with a `data_source` and `signal` value; this is for the output dataframe.  You can just define a descriptive dummy signal, describing your data.  If you aren't using covidcast data, this will not be used for anything besides formatting the output dataframe.
  
  3. You still need to define a `geo_type` and `signal_aggregation` type (there are no defaults) even if they are not used (as in the following example).

We are going to use a dataset for COVID from Toronto, from the `covid19.analytics` package, Here, we change the dataset into a dataframe having columns `time_value`, `geo_value` and `value` to make it similar to covidcast dataframes.  Additionally, we define a `get_aus_data` function to get data that exists `as_of` a certain date (data that is recorded up to that date in this context).


```{r, include = TRUE}
library(covid19.analytics)

tor <- covid19.Toronto.data() %>% as.data.frame(.)

tor

tor <- tor %>% dplyr::mutate(
  geo_value = paste(.$Province.City, .$Country.Region, sep = ", "))

tor <- tor %>% tidyr::pivot_longer(
  cols = starts_with("202"), names_to = "time_value", values_to = "value")

tor

tor <- tor %>% dplyr::filter(.$status == "Deaths") %>% 
  dplyr::select(-Lat, -Long, -Country.Region, -Province.City, -status)

tor

attributes(tor)$metadata <- list(.data = data.frame(data_source = c("jhu"), signal = c("Deaths")))

tor


```

First, you can pass all of your data to `get_predictions` as an input in whatever form you have chosen for your forecaster (list, data frame, etc.).  It is important to note that the entirety of the data will be passed to the forecaster for each single day prediction, and selecting the date must be done within the forecaster.  That structure will roughly look like this example:

```
my_forecaster <- function(df,
                          forecast_date,
                          signals,
                          incidence_period = "epiweek",
                          ahead,
                          geo_type,
                          my_data,
                          ...) {
  forecast_data <- my_data %>% dplyr::filter(.$time_value <= forecast_date)
  # DO FORECASTING
  }
```

Here we implement the basic forecaster for the Australian residents dataset by passing in the whole dataset and then filtering based on date.

```{r, include = TRUE}
growth_factor_forecaster <- function(df,
                                     forecast_date,
                                     signals,
                                     incidence_period = "epiweek",
                                     ahead,
                                     geo_type,
                                     growth_factor) {
  dat <- list()
  for (a in seq_along(ahead)) {
    # recall the first row of signals is the response
    dat[[a]] <- df %>%
      dplyr::filter(.$data_source == signals$data_source[1],
                    .$signal == signals$signal[1])  %>%
      dplyr::group_by(.$geo_value) %>%
      dplyr::arrange(.$time_value) %>%
      dplyr::slice_tail(n = 1) %>%
      dplyr::mutate(value = .$value * growth_factor ** a,
                    quantile = NA) %>%
      dplyr::select(.$geo_value, .$value, .$quantile) %>%
      dplyr::ungroup() 
  }
  names(dat) <- as.character(ahead)
  dplyr::bind_rows(dat, .id = "ahead") %>%
    dplyr::mutate(ahead = as.integer(ahead))
}

baseline_tor_forecaster <- function(df,
                                    forecast_date,
                                    signals,
                                    incidence_period = c("epiweek", "day"),
                                    ahead,
                                    geo_type,
                                    symmetrize = TRUE,
                                    tor_df){
  return (baseline_forecaster(df = tor_df, 
                              forecast_date = forecast_date,
                              signals = signals,
                              incidence_period = incidence_period,
                              ahead = ahead,
                              geo_type = geo_type,
                              symmetrize = symmetrize))
}
```

Another possibility is to have a querying function either passed to your forecaster or within your forecaster.  This may be slower, but if you have a large amount of data or you have similar `as_of` functionality to covidcast, this can be a simpler way to get the correct data as opposed to passing it all initiatially.  That structure will look like this example:


```
my_forecaster <- function(df,
                          forecast_date,
                          signals,
                          incidence_period = "epiweek",
                          ahead,
                          geo_type,
                          query_my_data,
                          ...) {
  forecast_data <- query_my_data(as_of = forecast_data, ...)
  # DO FORECASTING
  }
```

Here we implement the same forecaster as above

Here we can plot 


```{r, include = TRUE}

baseline_tor_forecaster <- function(df,
                                    forecast_date,
                                    signals,
                                    incidence_period = c("epiweek", "day"),
                                    ahead,
                                    geo_type,
                                    symmetrize = TRUE,
                                    tor_df){
  return (baseline_forecaster(df = tor_df, 
                              forecast_date = forecast_date,
                              signals = signals,
                              incidence_period = incidence_period,
                              ahead = ahead,
                              geo_type = geo_type,
                              symmetrize = symmetrize))
}

forecast_dates <- get_covidhub_forecast_dates("CMU-TimeSeries")
forecast_dates <- forecast_dates[forecast_dates >= "2020-10-01" & 
                                   forecast_dates <= "2020-10-31"]

# Put dummy signal for output dataframe, to have and for the baseline forecaster to use
signals <- tibble(date_source = c("jhu"),
                  signal = c("Deaths"),
                  start_day = "2020-04-01")

tor_predictions <- get_predictions(forecaster = baseline_tor_forecaster,
                                  name_of_forecaster = 'Baseline',
                                  signals = signals,
                                  forecast_dates = forecast_dates,
                                  incidence_period = 'epiweek',
                                  ahead = c(1,2,3),
                                  geo_type = 'county',
                                  signal_aggregation = 'long',
                                  use_covidcast = FALSE,
                                  tor_df = tor)

head(tor_predictions)


```