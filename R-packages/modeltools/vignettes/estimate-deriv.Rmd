---
title: 2. Estimate derivatives of signals 
description: Estimate derivatives of signal values, using various methodologies.
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{2. Estimate derivatives of signals}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

TODO, blah load data

```{r}
library(covidcast)

start_day <- "2020-06-01"
end_day <- "2020-11-15"
geo_values <- c("ca", "fl", "ny", "tx")

case_rates <- suppressMessages(
  covidcast_signal(data_source = "usa-facts", 
                   signal = "confirmed_7dav_incidence_prop",
                   start_day = start_day, end_day = end_day, 
                   geo_type = "state", geo_values = geo_values))

summary(case_rates)
```

## Estimating derivatives via linear regression

TODO, blah try linear regression

```{r}
library(modeltools)
library(dplyr)

case_rates <- estimate_deriv(case_rates, method = "lin", n = 14)

case_rates %>% 
  arrange(geo_value) %>% 
  select(geo_value, time_value, value, deriv) 
```

TODO, blah plot it

```{r, fig.width = 8, fig.height = 4}
library(ggplot2)
library(gridExtra)

state = "fl"
threshold = 0.25

p1 <- ggplot(case_rates %>% filter(geo_value == state),
             aes(x = time_value, y = value)) +
  geom_line() + 
  geom_point(data = case_rates %>% 
               filter(geo_value == state, deriv >= threshold),
             aes(x = time_value, y = value), color = "red") + 
  labs(x = "Date", y = "Cases per 100,00 people") 

p2 <- ggplot(case_rates %>% filter(geo_value == state),
             aes(x = time_value, y = deriv)) +
  geom_line() + 
  geom_hline(yintercept = threshold, linetype = 2) +
  labs(x = "Date", y = "Derivative (linear regression)") 

grid.arrange(p1, p2, nrow = 1)
```

## Estimating derivatives via smoothing spline

TODO, blah try smoothing splines two ways, plot them

```{r, fig.width = 8, fig.height = 4}
case_rates <- estimate_deriv(case_rates, method = "ss", n = 28,
                             col_name = "deriv_ss1", df = 8)

case_rates <- estimate_deriv(case_rates, method = "ss", n = 28,
                             col_name = "deriv_ss2", cv = TRUE)

p1 <- ggplot(case_rates %>% filter(geo_value == state), 
             aes(x = time_value, y = value)) +
  geom_line() + 
  geom_point(data = case_rates %>% 
               filter(geo_value == state, deriv_ss1 >= threshold),
             aes(x = time_value, y = value), color = "red") + 
  geom_point(data = case_rates %>% 
               filter(geo_value == state, deriv_ss2 >= threshold),
             aes(x = time_value, y = value), color = "blue", shape = 21) +
  labs(x = "Date", y = "Cases per 100,00 people") 

p2 <- ggplot(case_rates %>% filter(geo_value == state), 
             aes(x = time_value)) +
  geom_line(aes(y = deriv_ss1), color = "red") + 
  geom_line(aes(y = deriv_ss2), color = "blue") + 
  geom_hline(yintercept = threshold, linetype = 2) +
  labs(x = "Date", y = "Derivative (smoothing spline)") 

grid.arrange(p1, p2, nrow = 1)
```

## Estimating derivatives via trend filtering 

TODO, blah try trend filtering two ways, plot them. As it takes a while (here 
using solution path algorithm from `genlasso` package), just compute derivatives
for Florida

```{r, fig.width = 8, fig.height = 4}
case_rates_state <- case_rates %>% filter(geo_value == state)

case_rates_state <- estimate_deriv(case_rates_state, method = "tf", n = 28, 
                                   col_name = "deriv_tf1", df = 8)

case_rates_state <- estimate_deriv(case_rates_state, method = "tf", n = 28, 
                                   col_name = "deriv_tf2", cv = TRUE)

p1 <- ggplot(case_rates_state, aes(x = time_value, y = value)) +
  geom_line() + 
  geom_point(data = case_rates_state %>% filter(deriv_tf1 >= threshold),
             aes(x = time_value, y = value), color = "red") + 
  geom_point(data = case_rates_state %>% filter(deriv_tf2 >= threshold),
             aes(x = time_value, y = value), color = "blue", shape = 21) +
  labs(x = "Date", y = "Cases per 100,00 people") 

p2 <- ggplot(case_rates_state, aes(x = time_value)) +
  geom_line(aes(y = deriv_tf1), color = "red") + 
  geom_line(aes(y = deriv_tf2), color = "blue") + 
  geom_hline(yintercept = threshold, linetype = 2) +
  labs(x = "Date", y = "Derivative (smoothing spline)") 

grid.arrange(p1, p2, nrow = 1)
```

## Post-hoc inspection

TODO blah we can set `keep_obj = TRUE` to keep around a second column with the
fitted model objects. For example, here, we can look at the p-values associated
with the estimated slopes from `lsfit()`

```{r}
case_rates <- estimate_deriv(case_rates, method = "lin", n = 14, 
                             keep_obj = TRUE)

class(case_rates$deriv_obj)
ls.print(case_rates$deriv_obj[[7]])
         
case_rates <- case_rates %>%
  rowwise() %>%
  mutate(p_value = quiet(
    tryCatch(ls.print(deriv_obj)$coef.table[[1]][2,"Pr(>|t|)"], 
             error = function(e) NA))) 

case_rates %>% 
  arrange(geo_value) %>% 
  select(geo_value, time_value, value, deriv, deriv_obj, p_value)
```